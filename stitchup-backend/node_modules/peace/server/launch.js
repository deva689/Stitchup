(function() {
    var gen1_asyncFor = function(test, incr, loop) {
        return new Promise(function(success, failure) {
            function testAndLoop(loopResult) {
                Promise.resolve(test()).then(function(testResult) {
                    if (testResult) {
                        Promise.resolve(loop()).then(incrTestAndLoop, failure);
                    } else {
                        success(loopResult);
                    }
                }, failure);
            }
            function incrTestAndLoop(loopResult) {
                Promise.resolve(incr()).then(function() {
                    testAndLoop(loopResult);
                }, failure);
            }
            testAndLoop();
        });
    };
    var self = this;
    var debug, log, createServer, launchBrowser, httpism, enableDestroy;
    debug = require("debug");
    log = require("debug")("peace:launch");
    createServer = require("./server");
    launchBrowser = require("chrome-launch");
    httpism = require("httpism");
    enableDestroy = require("server-destroy");
    module.exports = function(testFolder, gen2_options) {
        var self = this;
        var port, agent, configure;
        port = gen2_options !== void 0 && Object.prototype.hasOwnProperty.call(gen2_options, "port") && gen2_options.port !== void 0 ? gen2_options.port : 8765;
        agent = gen2_options !== void 0 && Object.prototype.hasOwnProperty.call(gen2_options, "agent") && gen2_options.agent !== void 0 ? gen2_options.agent : true;
        configure = gen2_options !== void 0 && Object.prototype.hasOwnProperty.call(gen2_options, "configure") && gen2_options.configure !== void 0 ? gen2_options.configure : function() {}();
        var server, app, httpServer, socketServer;
        log("Launching server for folder " + testFolder + " on port " + port);
        server = createServer(testFolder);
        app = server.app;
        httpServer = server.http;
        socketServer = server.socket;
        enableDestroy(httpServer);
        socketServer.on("connection", function(socket) {
            return socket.on("log", function(logEntry) {
                return console.log.apply(console, logEntry.args);
            });
        });
        socketServer.on("connection", function(socket) {
            return socket.on("log", function(logEntry) {
                return debug("peace:" + logEntry.source).apply(debug, logEntry.args);
            });
        });
        if (configure) {
            configure(httpServer, socketServer, app);
        }
        return new Promise(function(serverStarted) {
            httpServer.on("listening", function() {
                var gen3_asyncResult, tasks, browser, stopAll;
                return new Promise(function(gen4_onFulfilled) {
                    log("peace is listening on port " + port);
                    gen4_onFulfilled(Promise.resolve(httpism.get("http://localhost:" + port + "/init")).then(function(gen3_asyncResult) {
                        gen3_asyncResult;
                        tasks = [];
                        if (agent) {
                            browser = launchBrowser("http://localhost:" + port + "/agent");
                            log("Browser opened " + browser.pid);
                            tasks.push(function() {
                                return new Promise(function(browserStopped) {
                                    browser.on("close", function() {
                                        console.log("Browser Closed");
                                        return browserStopped();
                                    });
                                    return browser.kill();
                                });
                            });
                        }
                        tasks.push(function() {
                            return new Promise(function(serverStopped) {
                                httpServer.on("close", function() {
                                    console.log("Peace Stopped");
                                    return serverStopped();
                                });
                                return httpServer.destroy();
                            });
                        });
                        stopAll = function() {
                            var gen5_items, gen6_asyncResult;
                            return new Promise(function(gen4_onFulfilled) {
                                gen5_items = tasks;
                                gen4_onFulfilled(function() {
                                    var gen7_i, gen8_asyncResult;
                                    return new Promise(function(gen4_onFulfilled) {
                                        gen7_i = 0;
                                        gen4_onFulfilled(gen1_asyncFor(function() {
                                            return gen7_i < gen5_items.length;
                                        }, function() {
                                            return ++gen7_i;
                                        }, function() {
                                            var task;
                                            task = gen5_items[gen7_i];
                                            return new Promise(function(gen4_onFulfilled) {
                                                gen4_onFulfilled(Promise.resolve(task()));
                                            });
                                        }));
                                    });
                                }());
                            });
                        };
                        console.log("Peace Started", port, testFolder);
                        return serverStarted({
                            stop: stopAll,
                            port: port
                        });
                    }));
                });
            });
            httpServer.on("error", function(e) {
                if (e.code === "EADDRINUSE") {
                    ++port;
                    return httpServer.listen(port);
                } else {
                    throw e;
                }
            });
            return httpServer.listen(port);
        });
    };
}).call(this);